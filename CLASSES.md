# Классы
## Пример класса и создания объекта

> **Класс** - шаблон, по которому делается **объект**. К примеру :  
> _Ученики_ - **класс**; _Петорв, Иванов, Васильев_ - **объекты**  
> _Машина_ - **класс**; _Ford, Toyota, Жигуи_ - **объекты**

```
class Person: # создание класса
    counter = 0 # общеклассовая переменная, считает, сколько всего объектов было создано


    def __init__(self, name, age):  # Первая функция, которая автоматически вызовется
        self.name = name  # self - сам объект, который мы создаём. При создании p1 будет p1
        self.age = age   
        Person.counter += 1 # обращение к переменной класса, добавляет 1


    def myfunc(self):
        print("Hello my name is " + self.name)


p1 = Person("John", 36) # создание объекта p1 с именем Джон, возрастом 36
p1.myfunc() # Вызов приветствия этого объекта
p2 = Person("Alex", 17) # создание второго объекта
print(Person.counter) # напечатать, сколько объектов создано

del p1.age # удалит возраст из объекта p1
del p2 # удалит объект p2, счётчик counter не уменьшится
```
## Наследование
> **Наследование** - создание класса, взяв за основу какой-то другой класс. 
>Все методы и переменные сохраняются.

```
class Student(Person): # создание класса 
    def __init__(self, name, age, grade):  
        super().__init__(name, age) # Делегирование, можно использовать Person вместо super, но нужно добавить self для род. инита
        self.grade = grade


    def wellcome(self):
        print(f"Welcome, {self.name}, to the {self.grade}th grade")

    
    # Если функцю ниже не объявлять, то вызовется родительская функция. 
    def myfunc(self):  # тут можно переназначить родительскую функцию, а можно не трогать
        Person.myfunc(self)  # вызов родительской функции, можно использовать super() вместо Person и не передавать self
        print(f"Это студент, надо добавить класс: {self.grade}")  #новая строчка


x = Student("Mike", 12, 5)
x.wellcome()
x.myfunc()

getattr(Student, 'counter', '100')  # 3-й параметр вернется, если не взлетитит 2-й
setattr(Student, 'has_book', True) # добавляем в студента аттрибут has_book
del Student.has_book # удалить аттрибут или так:
delattr(Student, 'has_book') 
```

>hasattr(obj, name) - проверяет наличие аттрибута в объекте

## Магические методы
```
__str__  - что будет выводиться в принте
__repr__ - как будет видеть тип объекта система 
__dict__ - увидеть все атрибуты класса
__len__ - как будет считаться длинна

__add__ - функционал на сложение # TODO: NotImplemented (в случ. отсутствия реализации слож. не будет рекурсивно искать)
__radd__ - сложение справа 
__mul__ - умножение
__sub__ - вычитание
__truediv__ - деление
__abs__ - модуль

__eq__ - сравнение (теряется возможность hash, если нужен, то надо определить)
__ne__,  __lt__,  __le__, __gt__, __ge__ - ?? != (not equal),< ,<=, >, >= 
__hash__ - переопреление поиска хэша (по умолчанию ищет от id)
__bool__ - результат bool(obj) если не реализован, будет смотреть на __len__

__call__ - делает экземпляр вызываемым

__getitem__
__setitem__
__delitem__

ниже в примере, переопределяет методы для итерабельных объектов

```

## Изменение атрибута в 1 объекте меняет во всех
```
class Cat():
    __shared_attr = {
        'breed': 'pers'
        'color': 'black'
    }

    def __init__(self):
        self.__dict__ = Cat.__shared_attr
# всё, что поменяется или добавится в каком-то объекте, поменяется во всех
```
## Доступ
```
_anything #  protected (лучше не использовать вне класса, 
# но язык спокойно позволит это делать)
__anything # private (вне класса не позволит получить доступ поимени,
 но можно использовать конструкцию any_object._classname__anything
```
## Свойства (property), декораторы

> @property # дескриптор данных, свойство, с завода геттер, по названию функции позволяет получить её результат, 
> при вызове () не используется. (можно сделать сеттер и делитер по названию свойства.сеттер или .делиттер)

> @staticmethod # дескрипторы не-данных, используется для обозначения статического метода, если не используется self
'пишеться через' ????
>
>staticmethod — то же, что функция вне класса, в неё не передаётся экземпляр в качестве первого аргумента.
>classmethod — то же, что метод класса, только в качестве первого аргумента передаётся класс экземпляра.
>
>можно использовать декоратор с параметром, тогда декоратор надо будет обернуть ещё одной функцией (TODO: разобраться)
>расшифровываться будет @decorator(param = 3) def func(): равносильно decorator(param = 3)(func)
>
>чтобы возвращался __doc__ оригинальной функции, а не декоратора 
>from functools import wraps, def bla(f): cache = {} @wraps def new_f() return f() return new_f
```
class Square:
    def __init__(self, side):
        self.__side = side
        self.__area = None

    @property
    def side(self):
        return self.__side

    @side.setter
    def side(self, s):
        self.__side = s
        self.__area = None

    @property
    def area(self):
        if not self.__area:
            print('calculate')
            self.__area = self.__side**2
        return self.__area


a = Square(2)
print(a.area)
print(a.area)
a.side = 5
print(a.area)
print(a.area)
```

```
# Пример кэша декоратором
@cached
def sqr(x):
    return x*x

@cached
def half(x):
    return x / 2

def cached(f):
    cache = {}
    def new_f(x):
        if x not in cache:
            cache(x) = f(x)
        return cache[x]

    return new_f        

```
## Итераторы, генераторы
>если определен 1 из этих 2-х методов, то объект итерабельный:
>__iter__ - получает итератор из итерабельного объекта
>__getitem__ - получает объект по индексу

>__next__ - метод итератора
```
class Vector:
    def __init__(self, *args):
        self.values = list(args)

    def __repr__(self):
        # вывод внутренней информации
        return str(self.values)

    def __getitem__(self, item):
        # если индекс существует, венуть объект, если нет - вывалить ошибку. может служить заменой __iter__
        if 0 <= item < len(self.values):
            return self.values[item]
        else:
            raise IndexError('Индекс за границами коллекции')

    def __setitem__(self, key, value):
        # переопределение записи по индексу
        if 0 <= key < len(self.values):
            self.values[key] = value
        else:
            raise IndexError('Индекс за границами коллекции')

    def __len__(self):
        return len(self.values)

    def __iter__(self):
        # создаёт итератор из класса ниже
        return SimpleIterator(self)

    # def __iter__(self):                       # логичнее так, т.к. генератор является итератором
    #     for idx in range(len(self.values)):
    #         yield self.values[idx]

class SimpleIterator:
    def __init__(self, example):
        self.limit = len(example)
        self.example = example
        self.counter = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.counter < self.limit:
            result = self.example[self.counter]
            self.counter += 1
            return result
        else:
            raise StopIteration
```

## Абстрактный класс
```
from abc import ABC, abstractmethod

# нельзя создавать экземпляры Employee
class Employee(ABC):
    def __init__(self, id, name):
        self.id = id
        self.name = name
    
    # обязательно нужно переопределить метод
    @abstractmethod
    def calculate_payroll(self):
        pass
```
        
## Теория, важнейшие механизмы ООП 

>**Абстракция**  — в объектно-ориентированном программировании это придание объекту характеристик, которые отличают его от 
>всех объектов, четко определяя его концептуальные границы. Основная идея состоит в том, чтобы отделить способ 
>использования составных объектов данных от деталей их реализации в виде более простых объектов, подобно тому,
>как функциональная абстракция разделяет способ использования функции и деталей её реализации в терминах более 
>примитивных функций, таким образом, данные обрабатываются функцией высокого уровня с помощью вызова функций низкого уровня.
>
>**Инкапсуляция** — свойство языка программирования, позволяющее пользователю не задумываться о сложности реализации 
>используемого программного компонента (что у него внутри?), а взаимодействовать с ним посредством предоставляемого 
>интерфейса (публичных методов и членов), а также объединить и защитить жизненно важные для компонента данные. 
>При этом пользователю предоставляется только спецификация (интерфейс) объекта.
>
>**Наследование** — один из четырёх важнейших механизмов объектно-ориентированного программирования (наряду с 
>инкапсуляцией, полиморфизмом и абстракцией), позволяющий описать новый класс на основе уже существующего 
>(родительского), при этом свойства и функциональность родительского класса заимствуются новым классом.
>
>**Полиморфизм** — возможность объектов с одинаковой спецификацией иметь различную реализацию.
>
>источник: https://gos-it.fandom.com/wiki/Основные_принципы_ООП:_инкапсуляция,_наследование,_полиморфизм

